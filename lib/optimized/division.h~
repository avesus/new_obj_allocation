#ifndef _DIVISION_H_
#define _DIVISION_H_

#include <stdint.h>
#include <type_traits>

#include <optimized/const_math.h>
#include <util/const_utils.h>

//////////////////////////////////////////////////////////////////////
// Hijacked from
// https://github.com/ridiculousfish/libdivide/blob/master/libdivide.h
// and modified for constexpr

template<typename T, T denum>
constexpr T
calculate_proposed_m() {
    const T pp2 = cmath::prev_p2<T>(denum);
    if constexpr (sizeof(T) == sizeof(uint64_t)) {
        __uint128_t n      = ((__uint128_t)pp2) << 64;
        uint64_t    result = (uint64_t)(n / denum);
        return result;
    }
    else {
        uint64_t n      = ((uint64_t)pp2) << 32;
        uint32_t result = (uint32_t)(n / denum);
        return result;
    }
}

template<typename T, T denum>
constexpr T
calculate_remained() {
    const T pp2 = cmath::prev_p2<T>(denum);
    if constexpr (sizeof(T) == sizeof(uint64_t)) {
        __uint128_t n      = ((__uint128_t)pp2) << 64;
        uint64_t    result = (uint64_t)(n / denum);
        result             = (uint64_t)(n - result * (__uint128_t)denum);
        return result;
    }
    else {
        uint64_t n      = ((uint64_t)pp2) << 32;
        uint32_t result = (uint32_t)(n / denum);
        result          = (uint32_t)(n - result * (uint64_t)denum);
        return result;
    }
}

template<typename T, T denum>
constexpr uint32_t
calculate_should_add() {
    const T pp2       = cmath::prev_p2<T>(denum);
    T       remainder = calculate_remained<T, denum>();

    const uint32_t e = denum - remainder;
    return e >= pp2;
}


template<typename T, T denum>
constexpr T
calculate_m() {
    const T pp2        = cmath::prev_p2<T>(denum);
    T       proposed_m = calculate_proposed_m<T, denum>();
    T       remainder  = calculate_remained<T, denum>();

    const uint32_t e = denum - remainder;

    if (e >= pp2) {
        proposed_m += proposed_m;
        T remainder_x2 = remainder + remainder;
        if (remainder_x2 >= denum || remainder_x2 < remainder) {
            ++proposed_m;
        }
    }
    return proposed_m + 1;
}

template<typename T, T denum>
constexpr T
do_div(T n) {

    if constexpr (cmath::is_pow2<T>(denum)) {
        return n / denum;
    }
    else {
        const uint32_t floor_log_d = cmath::ulog2<T>(cmath::prev_p2<T>(denum));
        const T        m           = calculate_m<T, denum>();
        T              res;
        if constexpr (sizeof(T) == sizeof(uint64_t)) {
            __uint128_t _n = n, _m = m;
            res = (_n * _m) >> 64;
        }
        else {
            uint64_t _n = n, _m = m;
            res = (_n * _m) >> 32;
        }
        if constexpr (calculate_should_add<T, denum>()) {
            res = ((n - res) >> 1) + res;
        }
        return res >> floor_log_d;
    }
}

template<typename T, T denum>
constexpr __m256i
do_div_vector(__mm256i n) {
    const uint32_t floor_log_d = cmath::ulog2<T>(cmath::prev_p2<T>(denum));

    // need to entirely seperate 32 and 64 because of avx prefixes
    if constexpr (sizeof(T) == sizeof(uint64_t)) {
        if constexpr (cmath::is_pow2<T>(denum)) {
            return _m256_srli_epi64(n, floor_log_d);
        }
        else {
            __m256i m      = _mm256_set1_epi64x(calculate_m<T, denum>());
            __m256i lomask = _mm256_set1_epi64x(0xffffffff);
            __m256i xh     = _mm256_shuffle_epi32(x, 0xB1);
            __m256i yh     = _mm256_shuffle_epi32(y, 0xB1);
            __m256i w0     = _mm256_mul_epu32(x, y);
            __m256i w1     = _mm256_mul_epu32(x, yh);
            __m256i w2     = _mm256_mul_epu32(xh, y);
            __m256i w3     = _mm256_mul_epu32(xh, yh);
            __m256i w0h    = _mm256_srli_epi64(w0, 32);
            __m256i s1     = _mm256_add_epi64(w1, w0h);
            __m256i s1l    = _mm256_and_si256(s1, lomask);
            __m256i s1h    = _mm256_srli_epi64(s1, 32);
            __m256i s2     = _mm256_add_epi64(w2, s1l);
            __m256i s2h    = _mm256_srli_epi64(s2, 32);
            __m256i hi     = _mm256_add_epi64(w3, s1h);
            hi             = _mm256_add_epi64(hi, s2h);
        }
    }
    else {
        if constexpr (cmath::is_pow2<T>(denum)) {
            return _m256_srli_epi32(n, floor_log_d);
        }

        else {
            __m256i m = _mm256_set1_epi32(calculate_m<T, denum>());

            // obviously I have no idea wtf I am doing
            __m256i hi_0_2 = _mm256_srli_epi64(_mm256_mul_epu32(n, m), 32);
            __m256i s_1_3  = _mm256_srli_epi64(n, 32);
            __m256i mask   = _mm256_set_epi32(-1, 0, -1, 0, -1, 0, -1, 0);
            __m256i hi_1_3 = _mm256_and_si256(_mm256_mul_epu32(s_1_3, m), mask);
            __m256i res    = _mm256_or_si256(hi_0_2, hi_1_3);
            if constexpr (calculate_should_add<T, denum>()) {
                `__m256i _res = _mm256_add_epi32(
                    _mm256_srli_epi32(_mm256_sub_epi32(n, res), 1),
                    res);
                return _mm256_srli_epi32(_res, floor_log_d);
            }
            else {
                return _mm256_srli_epi32(res, floor_log_d);
            }
        }
    }
}


#endif
